require(magicaxis)
archr_colors <- ArchR::ArchRPalettes
clusters_image <- function(data, clust, fig.fn, K, shades=colorRampPalette(c("blue", "black", "yellow")),
        shade_count=3, zlim=c(0,1),
        image_to_file=T, width=600, height=1400,label=NULL)
{
        if (is.null(dim(data))) {
                mat = as.matrix(data[order(clust)])
        } else {
                mat = as.matrix(data[order(clust),])
        }
        if (image_to_file) {
                png(fig.fn, width =width, height = height)
        }
        imgGrid <- matrix(c(1:2),nrow=1)
        layout(imgGrid, widths = c((9/10)*(width/height),(1/10)*(width/height)), heights = c(1,1), respect = T)
        par(mar=c(3, 4, 1, 6))
        image(t(mat),zlim=zlim,col=shades(shade_count),xaxt="n", yaxt="n")
#         par(mar=c(5,2,4,2))
#         image.scale(as.matrix(diagMatrix),zlim=zlim, col=shades(1000),axis.pos=4,adj=1)
        cur_y = 0
        tot_y = dim(mat)[1]
        ypos = c()
        for (i in 1:K) {
                ypos = c(ypos, (cur_y + 0.5*sum(clust==i))/tot_y)
                cur_y = cur_y + sum(clust==i)
                abline(a=cur_y/tot_y, b=0, col="gray")
        }
        axis(2, at=ypos, labels=seq(1,K,1), las=2)
        axis(4, at=ypos, labels=table(clust), las=2)
        
        par(mar=c(height/20,2,1,3))
        image.scale(t(mat),zlim=zlim, col=shades(shade_count),axis.pos=4,label=label)
        if (image_to_file) {
                dev.off()
        }
}


cluster_and_plot <- function(data, fn, fig.fn, K, shades=colorRampPalette(c("blue", "white", "red")),
        shade_count=3, zlim=c(0,1),
        image_to_file=F, plot_image=T, fig.width=600, fig.height=1400,label='') {
  write.table(data, fn, sep="\t", quote=F, row.names=FALSE)
  message("clustering...")
  system(sprintf("/home/hpc/bonev/projects/hic/test/scripts/TGLKMeans_static %s %s euclid -allow_nas=1", fn, K), ignore.stdout = TRUE, ignore.stderr = TRUE)
  mat <- read.table(fn, header=T)
  mat_k <- read.table(paste(fn, "kclust", sep="."),header=T)
  mat_dim = dim(mat)[2]
  mat[is.na(mat)] = 0

  if (missing(zlim)) {
        zlim=c(min(as.vector(mat)), max(as.vector(mat)))
  }

  s <- split(mat, mat_k$clust)
  ss <- sapply(s, colMeans)
  v <- as.vector(ss)

  breaks=seq(zlim[1], zlim[2], length.out=2*shade_count-1)
  breaks[1] = breaks[1] - 1
  a <- cut(v, breaks, labels=1:(2*shade_count-2))
  m <- matrix(as.numeric(a), nrow=nrow(ss))
  new_order <- do.call(order, as.data.frame(t(m)))
  mat$clust <- mat_k$clust + 1
  cluster_permuations <- data.frame(clust=new_order, new_clust=1:K)
  new_mat <-  left_join(mat, cluster_permuations, by="clust")

  system(sprintf("rm %s*", fn))
  new_mat = cbind(new_mat[,-(grep("clust", colnames(new_mat)))], clust=new_mat$new_clust)
  write.table(new_mat, fn, sep="\t", quote=F, row.names=FALSE)
  if (plot_image) {
        clusters_image(new_mat[,-(grep("clust", colnames(new_mat)))],
                new_mat[,grep("clust", colnames(new_mat))], fig.fn, K=K, shades=shades, zlim=zlim, image_to_file=image_to_file,shade_count=shade_count,
                width=fig.width, height=fig.height,label=label)

  }
  return(new_mat)
}

###################################################################################################
#'  Plot Binned observed data from a hic track
#'
#' \code{plotBinned}
#'
#' This function plots a hic matrix with a given bin size saved by extractBinned funciton together with a 1D track of choice and performs matrix balancing if desired.
#' Output is a png file.
#'
#' @param trackdb misha database to use. Defaults to the one set in the config file.
#' @param extra_tracks Which additional track to plot below the heatmap. Only tracks containing the string with **cell** parameter will be considered. Default is eigen tracks.
#' @param extractWhat How to bin data for extra tracks. One of 'avg', 'max'.
#' @param cells Which condition to work on. Vector of conditions is also accepted. Should exist in the the file generated by extractBinned.
#' @param init_cell Set to another condition if you want to normalize the scalebar in every condition based on the total number of contacts. Set the same as cell if no normalization is required.
#' @param chr Which chromsome to plot. Should be extracted previously and stored in the output data file by extractBinned.
#' @param region If plotting a specific region. Format is a 2D interval - see example.
#' @param path Where to save the resulting image. Default is "analysis/compartments"
#' @param binSize Resolution of the hic matrix to plot
#' @param file_f Full path to the file generated by extractBinned.
#' @param cutoff_value Maximim value of the scalebar to plot. All values higher than this are plotted with the same color.
#' @param obs_colors scheme to use when plotting observed values. Default is white-darkRed.
#' @param norm_colors scheme to use when plotting normalized values. Default is purple-white-yellow.
#' @param zlim_norm Vector with the lower and upper limit of the values to plot the normalized map. Default is c(-3,3).
#' @param balance Boolean whether to use matrix balancing (KR) or not.
#'
#' @examples
#' plot_region <- gintervals.2d('2L',10e6,20e6,'2L',10e6,20e6)   #make a 2D region to plot
#' col_obs <- colorRampPalette(c("white","orange","red","darkRed")) #make a color scale for observed values
#' file_nm <- paste0(main_f,'data/extractedBins/eGFP_50kb_chr2L')
#' plotBinned(extra_tracks=gtrack.ls('eigen'),cells='eGFP',init_cell='eGFP',chrs='chr2L',region=plot_region,binSize=5e4,path=paste0(main_f,'analysis/compartments/'),file_f=file_nm,plot_what='obs',balance=T)
#'
#' @export
##########################################################################################################
plotBinned <- function(trackdb=trackdb,extra_tracks=eigen_tracks,extractWhat='avg',cells=cells,init_cell=cells[1],chrs=chrs,region=gintervals.2d(chrs),binSize=binSize,path=paste0(main_f,'analysis/compartments/'),file_f='test.pdf',cutoff_value=NULL,obs_colors=colorRampPalette(c("white","orange","red","darkRed")),norm_colors=wide_red_blue_pal,plot_what=c('obs','norm'),zlim_norm=c(-3,3),balance=F,fig_name=NULL,width,height){
	for (t in 1:length(extra_tracks)){
		gvtrack.create(paste0('v_',extra_tracks[t]), extra_tracks[t], extractWhat)
	}
	df_list <- get(load(file_f))

	idx1 <- floor(region[,2]/binSize)+1
	idx2 <- floor(region[,3]/binSize)+1
	idx3 <- floor(region[,5]/binSize)+1
	idx4 <- floor(region[,6]/binSize)+1
	
	if(is.null(fig_name)){
	  fig_name <- paste0(path,cell,'_',chr,'.png')
	} 
	pdf(fig_name,width=width*length(cells),height=height)
	layout(mat = matrix(c(1:(length(cells)*2+2)), nrow = 2, ncol = length(cells)+1,byrow = F),heights = c(4, 0.5),widths = c(rep(4,length(cells)),0.5),respect=T) 
	#layout(matrix(1:((length(tracks)+1)*length(cells)),length(tracks)+1,length(cells),byrow=F),c(rep(4,length(cells)),1), c(4,rep(0.5,length(tracks))))
	for (cell in cells){
		tracks <- extra_tracks[grep(cell,extra_tracks)]
		init_temp <- df_list[[init_cell]]
		temp_list <- df_list[[cell]]
		for (chr in chrs){
			if (!balance) {
				init_obs <- init_temp[[as.character(chr)]]$obs
				df_cast_obs <- temp_list[[as.character(chr)]]$obs
				df_cast_exp <- temp_list[[as.character(chr)]]$exp
				df_cast_norm <- temp_list[[as.character(chr)]]$norm
			} else {
				init_obs <- init_temp[[as.character(chr)]]$obs_KR
				df_cast_obs <- temp_list[[as.character(chr)]]$obs_KR
				df_cast_exp <- temp_list[[as.character(chr)]]$exp
				df_cast_norm <- temp_list[[as.character(chr)]]$norm
			}
			init_obs <- init_obs[idx1:idx2,idx3:idx4]
			if (is.null(cutoff_value)){
				cutoff_value <- as.numeric(quantile(melt(init_obs)$value,0.95))
				}
			df_cast_obs <- df_cast_obs[idx1:idx2,idx3:idx4]
			df_cast_norm <- df_cast_norm[idx1:idx2,idx3:idx4]
			max_value <- round(cutoff_value*sum(df_cast_obs)/sum(init_obs),ifelse(balance,6,0))
			df_cast_obs[df_cast_obs>max_value] <- max_value
			df_cast_exp[df_cast_exp>max_value] <- max_value

			df_cast_norm [df_cast_norm<zlim_norm[1]] <- zlim_norm[1]
			df_cast_norm [df_cast_norm>zlim_norm[2]] <- zlim_norm[2]
			message(max_value)
			df_tracks <- gextract(paste0('v_',tracks[grep(cell,tracks)]),intervals=gintervals(region[,1],region[,2],region[,3]),iterator=binSize)
			if (grepl('obs',plot_what)){
			  if (which(cells%in%cell)==1){
			    par(mar=c(0.5,0.5,0.5,0.5))
			  } else {
			    par(mar=c(0.5,0.5,0.5,0.5))
			  }
			  #hm <- Heatmap(as.matrix(df_cast_obs),cluster_columns = F,cluster_rows=F,show_row_names = F,show_column_names = F,col=obs_colors(1000),show_heatmap_legend = F,raster_quality = 1)
				image(rotate(as.matrix(df_cast_obs)), zlim=c(0,max_value),  col=obs_colors(1000),xaxt="n",yaxt="n",xlab='', ylab='',useRaster=TRUE) #plot the image
				text(gsub('E14_','',cell),x=.9,y=.9,font=2,cex = 2)
				for (i in 1:length(tracks)){
					min_label <- round(min(df_tracks[,i+3],na.rm=T),1)
					max_label <- round(max(df_tracks[,i+3],na.rm=T),1)
					par(xaxs="i")
					if (which(cells%in%cell)==1){
					  par(mar=c(0.5,0.5,0,0.5))
					} else {
					  par(mar=c(0.5,0.5,0,0.5))
					}
						if (grepl('eigen',tracks[i])){
						  if(which(cells%in%cell)==1){
						    axis_labels <- c(paste0('-',0.06),0,paste0('+',0.06))
						  } else {
						    axis_labels <- NA
						  }
							barplot(df_tracks[,i+3], axes=T, space=0, col=ifelse(df_tracks[,i+3]>0,"red","blue"),border = NA,ylim=c(-0.06,0.06),xlab='', ylab='', yaxt='n', xaxt='n')
							axis(2, labels=axis_labels,at=c(-0.06,0,0.06), cex.axis=0.7,hadj=0.6, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
						} else if (grepl('methylation',tracks[i])){
						  if(which(cells%in%cell)==1){
						    axis_labels <- c(0,100)
						  } else {
						    axis_labels <- NA
						  }
						  plot(x=1:nrow(df_tracks),y=rollmean(df_tracks[,i+3],3,na.pad=T),lwd=1,type='l',ylim=c(0,100),col='black',bty ='n',xlab='', ylab='', yaxt='n', xaxt='n',cex.lab=1.3)
						  axis(2, labels=axis_labels,at=c(0,100),outer = F, cex.axis=1, las=2)
						 # mtext(ifelse(which(cells%in%cell)==1,'% CpG Methylation',''), side=2, line=2, las=3,cex = 0.5)
						} else {
						  if(which(cells%in%cell)==1){
						    axis_labels <- c(min_label,max_label)
						  } else {
						    axis_labels <- NA
						  }
							barplot(df_tracks[,i+3], axes=T, space=0, col='black',border = NA,xlab='', ylab='', yaxt='n', xaxt='n',ylim=c(min_label,max_label))
							axis(2, labels=axis_labels,at=c(min_label,max_label), cex.axis=0.7,hadj=0.6, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
						}
				}
			}

			if (grepl('norm',plot_what)){
				png(paste0(path,cell,'_chr',chr,'_norm.png'),width=1600,height=1600,res=100)
				layout(matrix(1:(length(tracks)+1),length(tracks)+1,1,byrow=T),c(4,rep(0.5,length(tracks))), c(4,rep(0.5,length(tracks))))
				par(mar=c(0.5,2,1,0.5))
				image(rotate(as.matrix(df_cast_norm)), zlim=zlim_norm,  col=norm_colors(1000),xaxt="n",yaxt="n",xlab='', ylab='') #plot the image
				for (i in 1:length(tracks)){
					min_label <- round(min(df_tracks[,i+3],na.rm=T),1)
					max_label <- round(max(df_tracks[,i+3],na.rm=T),1)
					par(xaxs="i")
					par(mar=c(0.5, 2, 0, 0.5))
						if (grepl('eigen',tracks[i])){
							barplot(df_tracks[,i+3], axes=T, space=0, col=ifelse(df_tracks[,i+3]>0,"red","blue"),border = NA,ylim=c(-0.06,0.06),xlab='', ylab='', yaxt='n', xaxt='n')
							axis(2, labels=c(paste0('-',0.06),0,paste0('+',0.06)),at=c(-0.06,0,0.06), cex.axis=0.7,hadj=0.6, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
						} else {
							barplot(df_tracks[,i+3], axes=T, space=0, col='black',border = NA,xlab='', ylab='', yaxt='n', xaxt='n')
							axis(2, labels=c(min_label,max_label),at=c(min(df_tracks[,i+3],na.rm=T),max(df_tracks[,i+3],na.rm=T)), cex.axis=0.7,hadj=0.6, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
						}
				}
				dev.off()

				pdf(paste0(path,cell,'_chr',chr,'_norm.scalebar.pdf'),width=2,height=8)
				par(mar=c(1,1,1,6.5))
				image.scale(as.matrix(1),zlim=zlim_norm, col=norm_colors(1000),axis.pos=4,adj=1)
				dev.off()
			}

		}
		
	}
	par(mar=c(0.5,0.5,0.5,1.5))
	image.scale(as.matrix(1),zlim=c(0,max_value), col=obs_colors(1000),axis.pos=4,adj=1,cex.axis=1,axis_lab=c('','',''))
	dev.off()
	}

###############################################################################################################
#'  Plot hic contact enrichment between ranked bin pairs using output from \code{rank_matrix}
#'
#' \code{plot_rankMatrix}
#'
#' This function generates heatmap plotting the the contact enrichment (observed/expected) for bin-pairs ranked by their eigenvector (or ChIP enrichment) values. In addition,it can also plot the average value of the eigenvector (and/or ChIP track) in each bin. Uses the file generated by \code{rank_matrix} as an input.
#'
#' @param path Where to save the resulting pdf file. Default is "/analysis/compartments/"
#' @param file_f File where the data is stored. Output from the rank_matrix function.
#' @param zlim Minimum and maximum value for the scalebar.
#' @param col Vector of colors to use for plotting.
#' @param plot_chip Boolean whether to plot eigenvector values (TRUE) or other track values per bin (FALSE).
#' @param mark misha path to any additional 1D tracks to plot (for example chipseq.ES_H3K9me3)
#'
#' @examples
#'
#' path=paste0(main_f,'/analysis/compartments/')
#' file_name <- paste0(main_f,'/data/extractedBins/','rankMatrix_100kb_ranks50')
#' col=wide_red_blue_pal(1000)
#' plot_rankMatrix(path=path,file_f=file_name,zlim=c(-1.5,1.5))   #Two samples, one chromosome.
#'
#' @export
##########################################################################################################
plot_rankMatrix <- function(path=paste0(main_f,'/analysis/compartments/'),out_f=NULL,cells=cells,file_f=file_f,zlim=c(-1.5,1.5),col=wide_red_blue_pal(1000),plot_chip=TRUE,mark){
  temp_list2 <- get(load(file_f))
	cells <- temp_list2$cells
	chrs <- temp_list2$chrs
	eigen_tracks <- temp_list2$eigen_tracks
	ranks <- temp_list2$ranks
	binSize <- temp_list2$binSize
	for (t in 1:length(eigen_tracks)){
		gvtrack.create(paste0('v_',eigen_tracks[t]), eigen_tracks[t], 'avg')
	}
	if(is.null(out_f)){
	  out_f <- paste0(path,'rankedMatrix_',ranks,'ranks.pdf')
	} 
	pdf(out_f,width=12*length(cells)+1,height=12)
	layout(matrix(c(1:(length(cells)*4+2)),nrow = 2,ncol = length(cells)*2+1,byrow=F),widths = c(rep(c(0.5,4),length(cells)*2)),heights =  c(rep(c(0.5,4),length(cells)*2)))
	for (cell in cells){

		eigen <- gextract(paste0('v_',eigen_tracks[grep(cell,eigen_tracks)]),intervals=gintervals(chrs),iterator=binSize)
		eigen$bin <- paste0(gsub('chr','',eigen$chrom),'_',eigen[,2]/binSize)
		intervals1 <- eigen[,1:3]
		intervals2 <- eigen[,1:3]
		eigen <- eigen[order(eigen[,4]),]
		eigen$rank <- ntile(eigen[,4], ranks)
		rank_matrix <- temp_list2[[cell]]$rank_matrix
		rank_matrix[rank_matrix>max(zlim)] <- max(zlim)
		rank_matrix[rank_matrix<min(zlim)] <- min(zlim)
		eigen_ranks <- ddply(eigen,.(rank),function(x){
			return(mean(x[,4],na.rm=T))
		})
		### Testing ratio calculation #####
		obs <- temp_list2[[cell]]$obs_matrix
		exp <- temp_list2[[cell]]$exp_matrix
		#e_lim1 <- sum(eigen_ranks$V1<=quantile(eigen_ranks$V1[eigen_ranks$V1<0],0.5))
		#e_lim2 <- which(eigen_ranks$V1>=quantile(eigen_ranks$V1[eigen_ranks$V1>0],0.5))[1]
		e_lim1 <- sum(eigen_ranks$V1<0)
		e_lim2 <- which(eigen_ranks$V1>0)[1]
    AA <- sum(obs[e_lim2:ranks,e_lim2:ranks])
    AB <- sum(obs[1:e_lim1,e_lim2:ranks])
    BB <- sum(obs[1:e_lim1,1:e_lim1])
    BA <- sum(obs[e_lim2:ranks,1:e_lim1])
    message(cell,': AA',AA,' BB:',BB,' AB:',AB,' BA:',BA)
		if (!plot_chip) {
		  par(mar=c(0, 0, 0, 0))
		  plot(NULL, xlim=c(0,1), ylim=c(0,1),xaxt="n",yaxt="n",xlab='', ylab='',bty="n")
		  text(gsub('E14_','',cell),x=0.5,y=0.5,font=2,cex=4)
			par(yaxs="i")
			par(mar=c(3, 3, 0.5, 0))
			barplot(rev(eigen_ranks[,2]), axes=T, space=0, col='gray10', horiz=T,border = NA,xaxt='n')
			par(xaxs="i")
			par(mar=c(0, 0.5, 3, 1))
			barplot(eigen_ranks[,2], axes=T, space=0, col='gray10',border = NA,yaxt='n')
			
		  par(mar=c(3,0.5,0.5,1))
			image(rotate(as.matrix(rank_matrix)), zlim=zlim,  col=col,xaxt="n",yaxt="n",xlab='', ylab='') #plot the image
			text(round((AA+BB)/(AB+BA),2),x = 0.5,y = 0.5,font=2,cex=4)
		#	dev.off()
		} else {
			gvtrack.create(paste0('v_',mark),mark,'avg')
			chip <- gextract(paste0('v_',mark),intervals=gintervals(chrs),iterator=binSize)
			chip$bin <- paste0(gsub('chr','',chip$chrom),'_',chip[,2]/binSize)
			chip <- chip[match(eigen$bin,chip$bin),]
			chip$rank <- eigen$rank
			chip_ranks <- ddply(chip,.(rank),function(x){
				return(mean(x[,4],na.rm=T))
			})
			pdf(out_f,width=12,height=12)
			par(mar=c(3,1,1,1))
			layout(matrix(c(9,8,5,7,6,4,3,2,1),3,3,byrow=T),c(0.5,0.5,4), c(0.5,0.5,4))
			image(rotate(as.matrix(rank_matrix)), zlim=zlim,  col=col,xaxt="n",yaxt="n",xlab='', ylab='') #plot the image
			par(yaxs="i")
			par(mar=c(3, 1, 1, 0))
			barplot(rev(eigen_ranks[,2]), axes=T, space=0, col='gray10', horiz=T,border = NA,xlim=c(-0.06,0.06),xaxt='n')
			axis(1, labels=FALSE,at=c(-0.06,0,0.06), cex.axis=1.8, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
			par(yaxs="i")
			par(mar=c(3, 1, 1, 0))
			barplot(rev(chip_ranks[,2]),ylim=c(0,100), axes=T, space=0, col='gray10', horiz=T,border = NA,xaxt='n')
			axis(1, labels=FALSE, cex.axis=1.8, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
			par(xaxs="i")
			par(mar=c(0, 1, 1, 1))
			barplot(eigen_ranks[,2], axes=T, space=0, col='gray10',border = NA,ylim=c(-0.06,0.06),yaxt='n')
			axis(2, labels=c(paste0('-',0.06),0,paste0('+',0.06)),at=c(-0.06,0,0.06), cex.axis=1.8, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
			par(xaxs="i")
			par(mar=c(0, 1, 1, 1))
			barplot(chip_ranks[,2],ylim=c(0,100), axes=T, space=0, col='gray10',border = NA,yaxt='n')
	#		axis_labels <- c("",round(max(chip_ranks[,2],na.rm=T),1))
	#		axis(2, labels=axis_labels,at=c(0,max(chip_ranks[,2])), cex.axis=1.8, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
			axis_labels <- c(0,100)
			axis(2, labels=axis_labels,at=c(0,100), cex.axis=1.8, las=2,lwd=0.5, lwd.ticks=0.5,tck=(-0.1))
			dev.off()
			gvtrack.rm(paste0('v_',mark))

		}
		write.table(eigen,paste0(path,cell,'_eigen_',ranks,'ranks.txt'),quote=F,col.names=T,row.names=F,sep='\t')
	}
	plot(NULL, xlim=c(0,1), ylim=c(0,1),xaxt="n",yaxt="n",xlab='', ylab='',bty="n")
	par(mar=c(3, 2, 0.5, 4))
	image.scale(as.matrix(1),zlim=zlim, col=col,axis.pos=4,adj=1)
	dev.off()
}

###############################################################################################################
#'  Plot cis decay profiles only considering contacts between compartments \code{comp_cisDecay}
#'
#' \code{plot_comp_cisDecay}
#'
#' This function generates heatmap plotting the the contact enrichment (observed/expected) for bin-pairs ranked by their eigenvector (or ChIP enrichment) values. In addition,it can also plot the average value of the eigenvector (and/or ChIP track) in each bin. Uses the file generated by \code{rank_matrix} as an input.
#'
#' @param plot_data Full path to the file containing the data to plot as generated by \code{comp_cisDecay}
#' @param plot_cell Which conditions to plots on the graph. Should be same or a subset of the parameter in \code{comp_cisDecay}.
#' @param plot_what One of 'AvsA','BvsB','AvsB','total_AvsA','total_AvsB','total_BvsB'. When containing total it returns the values per track, when not - plots the cis decays on the plot.
#' @param min_dist Minimum distance to consider when counting contacts. Default value - 1000.
#' @param max_dist Maximum distance to consider when counting contacts. Default value - 2e8. It is recommended to extract the data using the length of the biggest chromosome as a guide for this value. It can be later adjusted for plotting.
#' @param normalize.by If true return values as log2(obs/exp).
#' @param ylim If set, use this vector of two values for lower and upper limit for plotting.
#' @param composite Boolean whether to draw the plot autonomously (TRUE) or inside a plot call (FALSE).
#' @param fig_f filename of the output figure. Will be generated inside path
#' @param fig.height Height (in inches) of the resulting figure.
#' @param fig.width Width (in inches) of the resulting figure.
#' @param colors Vector of colors to use for plotting. Should have the same length as plot_cell
#' @param disp_colors filename of the output figure. Will be generated inside path
#' @param lty line type to use. Same values as plot.
#' @param returnData Boolean whether to return calculated data. Most useful when plotting total values.
#' @param smooth Boolean whether to loess smooth the data.
#' @param legend_pos Position of the plot legend. Takes same values as default legend.
#'
#' @examples
#'
#' path <- paste0(main_f,'analysis/cis_decay/')
#' file_name <- 'comp_domains'
#' plot_comp_cisDecay(plot_data=paste0(path,file_name),plot_cell=c('D0','D2','D4'),plot_what='BvsB',min_dist=10e6,max_dist=1.5e8,fig.height=6,fig.width=6,smooth=T,legend_pos="topleft")    #ylim=c(value1,value2)
#'
#'
#' @export
##########################################################################################################
plot_comp_cisDecay <- function(plot_data,plot_cell=cells,plot_what=c('AvsA','BvsB','AvsB','total_AvsA','total_AvsB','total_BvsB'),min_dist=4e6,max_dist=2e8,normalize.by='exp',ylim=NULL,composite=FALSE,fig_f=paste0(path,plot_what,'.pdf'),fig.height=4,fig.width=4,colors=rainbow(length(plot_cell)),disp_colors=colors,lty=1,returnData=FALSE,smooth=F,legend_pos="topright"){
	plot_data <- get(load(plot_data))
	log_base=10
#	start_n <- round(log(4e6) / log(log_base),2)
#	end_n <- round(log(2e8) / log(log_base),2)
#	dist = log_base^seq(start_n, end_n, by=0.2/log_base)
	dist = plot_data[['dist']]
	# 	dist = seq(start_n, end_n, by=0.2/log_base)[-1]
	min_ind <- max(1,findInterval(min_dist,dist))
	max_ind <- findInterval(max_dist,dist)
	dist <- dist[min_ind:max_ind]
	list_data <- list()
	if (grepl('total',plot_what)){
		means <- data.frame(matrix(NA, nrow = 1, ncol = length(plot_cell)))
		colnames(means)=plot_cell
		sd_df <- means
		for (i in 1:length(plot_cell)){
			cell <- plot_cell[i]
			data <- plot_data[[cell]]
			if (plot_what=='total_AvsA'){
				data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsA'])))),na.rm=T)/colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_AvsA'])))),na.rm=T)
			} else if(plot_what=='total_AvsB'){
				data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsB'])))),na.rm=T)/colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_AvsB'])))),na.rm=T)
			} else if(plot_what=='total_BvsB'){
				data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_BvsB'])))),na.rm=T)/colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_BvsB'])))),na.rm=T)
			}
			means[,i]  <- mean(log2(data),na.rm=T)
			sd_df[,i] <- sd(log2(data),na.rm=T)/sqrt(length(data))
			list_data[[plot_cell[i]]] <- log2(data)
		}
		dist <- seq(1,length(plot_cell),by=1)
	} else {
		means <- data.frame(matrix(NA, nrow = length(dist), ncol = length(plot_cell)))
		colnames(means)=plot_cell
		row.names(means) <- round(dist,2)
		sd_df <- means
		for (i in 1:length(plot_cell)){
			cell <- plot_cell[i]
			data <- plot_data[[cell]]
			if (plot_what=='AvsA'){
				if (normalize.by=='exp'){
					data <- log2(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsA']))),na.rm=T)/as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_AvsA']))),na.rm=T))
				} else if (normalize.by=='sum'){
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsA']))))
					data <- data/colSums(data,na.rm=T)
				} else if (normalize.by=='bin'){
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsA']))))
					data <- data/colSums(data,na.rm=T)
					data <- adply(data,1,function(x){log10(x/(dist * (sqrt(2)-1)))})
				}
			} else if(plot_what=='AvsB'){
				if (normalize.by=='exp'){
					data <- log2(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsB']))),na.rm=T)/as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_AvsB']))),na.rm=T))
				} else if (normalize.by=='sum'){
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsB']))))
					data <- data/colSums(data,na.rm=T)
				} else if (normalize.by=='bin'){
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_AvsB']))))
					data <- data/colSums(data,na.rm=T)
					data <- adply(data,1,function(x){log10(x/(dist * (sqrt(2)-1)))})
				}
			} else if(plot_what=='BvsB'){
				if (normalize.by=='exp'){
					data <- log2(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_BvsB']))),na.rm=T)/as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_BvsB']))),na.rm=T))
				} else if (normalize.by=='sum'){
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_BvsB']))))
					data <- data/colSums(data,na.rm=T)
				} else if (normalize.by=='bin'){
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_BvsB']))))
					data <- data/colSums(data,na.rm=T)
					data <- adply(data,1,function(x){log10(x/(dist * (sqrt(2)-1)))})
				}
			}
			row.names(data) <- dist
			is.na(data) <- sapply(data, is.infinite)
			data <- data[complete.cases(data),]
			means[,i] <- apply(data,1,mean,na.rm=T)
			sd_df[,i] <- apply(data,1,sd,na.rm=T)/sqrt(ncol(data))
			list_data[[plot_cell[i]]] <- log2(data)
		}
	}
	if (!composite){
		plot_max <- max(means+sd_df,na.rm=T)
		plot_min <- min(means-sd_df,na.rm=T)
		pdf(fig_f,width=fig.width,height=fig.height)
		plot(log10(dist),y=rep(NA,length(dist)),ylim=if(is.null(ylim)){c(plot_min,plot_max)} else {ylim},type='n',main=paste0(plot_what),ylab="log2(obs/exp)",xaxt='n',xlab='')
		axis_pos <- seq(min(log10(dist)),max(log10(dist)),length.out=8)
		axis_labels <- paste0(round_any(10^axis_pos,1000000)/1000000," Mb")

		if(grepl('total',plot_what)){
			axis(1, at=log10(dist),labels=plot_cell, las=1,cex.axis=1.2)
		} else {
			axis(1, at=axis_pos, labels = FALSE)
			text(axis_pos, par("usr")[3], labels = axis_labels, srt = 45,adj = c(1.1,1.1), xpd = TRUE)
# 			minor.ticks.axis(1,9,mn=3,mx=8)
			}
	}
		if (grepl('total',plot_what)){
				dispersion(log10(dist),means[1,],sd_df[1,],display.NA=FALSE,type='l',fill=makeTransparent(ifelse(grepl('intra',plot_what),'orange','purple'),alpha=0.1))
				lines(log10(dist),means[1,],col=ifelse(grepl('intra',plot_what),'orange4','purple4'),lwd=2,lty=lty)
		} else {
			for (i in (1:ncol(means))){
				if (smooth){
					dispersion(log10(dist),predict(loess(means[,i] ~ log10(dist), data.frame(x=log10(dist), y=means[,i]))),predict(loess(sd_df[,i] ~ log10(dist), data.frame(x=log10(dist), y=sd_df[,i]))),display.NA=FALSE,type='l',fill=makeTransparent(as.character(disp_colors[i]),alpha=0.1))
					lines(log10(dist),predict(loess(means[,i] ~ log10(dist), data.frame(x=log10(dist), y=means[,i]))),col=colors[i],lwd=2,lty=lty)
				} else {
					dispersion(log10(dist),means[,i],sd_df[,i],display.NA=FALSE,type='l',fill=makeTransparent(as.character(disp_colors[i]),alpha=0.5))
					lines(log10(dist),means[,i],col=colors[i],lwd=2,lty=lty)
				}
			}
		}
	if (!composite){
		grid()
		legend(x=legend_pos,legend=if(grepl('total',plot_what)){gsub('total_','',plot_what)} else {colnames(means)},cex=1,lty=rep(1,ncol(means)),col=if(plot_what=='total_intra'){'orange4'} else if (plot_what=='total_intra'){'purple4'} else {colors})
		dev.off()
	}
	if(returnData){return(list(means=means,sd=sd_df,data=list_data))}
}

##############################################################################################################################################
#' Plots the average contact enrichment per TAD.
#'
#' \code{plot_averageTAD}
#'
#' This function operated in two modes specified by the parameter stats_f. If true it will calculate the contact enrichment inside and outside TADs as shown in Bonev et al., 2017 - Figure S3A. If False it will extend each TAD by its length, split it in 100 bins and then calculate the average contact enrichment per bin to determine averageTAD profile as Bonev et al., 2017 - Figure 3A.
#'
#' @param tracks Which combined insulation tracks to work on. Defaults to all insulation tracks listed in the config file. Only tracks for the selected conditions will be further considered.
#' @param cells Which conditions to work on. Vector of conditions is also accepted. Defaults to conditions listed in the config file.
#' @param path Folder where the input file generated by \code{averageTAD} is located.
#' @param file_f Name of the input file generated by \code{averageTAD}.
#' @param bins How many bins to split the extended domains. Use smaller number for sparse data and bigger number for high-resolution data. Recommended 50/100.
#' @param stats_f Controls whether to generate data to plot averageTAD (if FALSE) or calculate contact enrichment inside and outside domains (if TRUE).
#' @param plot_what Leave blank to include all domains in the analysis, or a vector of values which are present in the column cluster of the domain bed file. If using default settings, you can separate domains by setting this to either 'A' or 'B'
#' @param zlim Vector specifying the minimum and maximum value for the contact enrichment scalebar.
#' @param z_colors Vector of colors used to plot the data when in stats_mode=F.
#' @param flip Boolean whether to flip the average TAD plot or plot it as a half-square map.
#' @param cell_colors Vector of colors to use for each condition when in stats_mode=T.
#' @param width Width of the resulting file in inches.
#' @param height Height of the resulting file in inches.
#'
#' @examples
#'
#' zlim=c(-1.7,1)            # For asymmetric color generation
#' blue_white_pal = colorRampPalette(c("purple", "navy", "blue", "#87FFFF", "white"))
#' white_red_pal = colorRampPalette(c("white","#FF413D", "black", "orange", "yellow"))
#' averageTAD_colors <- c(blue_white_pal(1000*length(seq(zlim[1],0,by=0.1))/length(seq(zlim[1],zlim[2],by=0.1))),white_red_pal(1000*length(seq(0,zlim[2],by=0.1))/length(seq(zlim[1],zlim[2],by=0.1))))
#' plot_averageTAD(tracks=all_tracks,cells=cells,path=path,file_f='test',stats_f=T,plot_what='',zlim=zlim,flip=T,z_colors=averageTAD_colors)
#'
#' @export
##########################################################################################################
plot_averageTAD <- function(tracks=all_tracks,add_matrix=NULL,mat_lim=NULL,cells,domains=NULL,domain_size=c(1e5,2e6),path,file_f,stats_f=T,plot_what='',zlim=c(-1.5,1.5),z_colors=wide_red_blue_pal(1000),flip=T,cell_colors=rainbow(length(cells)),width=1.5*length(cells),height=6,norm='norm',fig_name=NULL,add_plot=F){
	file_f <- paste0(path,file_f)
	if (plot_what=='A'){idx=2} else if (plot_what=='B') {idx=1} else {idx=plot_what}
	if(stats_f){
	file_f <- file_f <- paste0(file_f,'_quantification')
	tad_list <- get(load(file_f))
	tad_norm <- list()
	if(is.null(fig_name)){
	  fig_name <- paste0(path,basename(file_f),'_',cell,'_',plot_what,'TADs.pdf')
	}
	for (cell in cells){
		idx_f <- length(tracks[grep(cell,tracks)])
		res <- as.data.frame(tad_list[[cell]]$res)
		colnames(res)[1] <- 'clust'
		if (idx_f==1){
			res_df <- adply(res,1,function(x){
				norm_inside <- log2(x[,2]/x[,3])
				norm_outside <- log2(x[,4]/x[,5])
				norm_obs <- (x[,2]-x[,4])/(x[,3]-x[,5])
				return(cbind(norm_inside,norm_outside,norm_obs))
			})
		} else {	
			res_df <- adply(res,1,function(x){
				norm_inside <- log2(rowSums(x[,2:(1+idx_f)],na.rm=T)/rowSums(x[,(2+idx_f):(1+2*idx_f)],na.rm=T))
				norm_outside <- log2(rowSums(x[,(2+2*idx_f):(1+3*idx_f)],na.rm=T)/rowSums(x[,(2+3*idx_f):ncol(x)],na.rm=T))
				norm_obs <- (rowSums(x[,2:(1+idx_f)],na.rm=T)-rowSums(x[,(2+2*idx_f):(1+3*idx_f)],na.rm=T))/(rowSums(x[,(2+idx_f):(1+2*idx_f)],na.rm=T)-rowSums(x[,(2+3*idx_f):ncol(x)],na.rm=T))
				return(cbind(norm_inside,norm_outside,norm_obs))
			})
		}	
		tad_norm[[cell]] <- res_df[,c('clust','norm_inside','norm_outside','norm_obs')]
	}
	nm <- list()
	for (i in 1:length(tad_norm)){
		if (plot_what==''){
			nm[[i]] <- tad_norm[[i]]$norm_inside
			nm[[i+length(tad_norm)]] <- tad_norm[[i]]$norm_outside
		} else {
			temp <- tad_norm[[i]]$norm_inside
			nm[[i]] <- temp[tad_norm[[i]]$clust==idx]
			temp <- tad_norm[[i]]$norm_outside
			nm[[i+length(tad_norm)]] <- temp[tad_norm[[i]]$clust==idx]
		}
	}

	df_nm <- sapply(nm, '[', seq(max(lengths(nm))))
	colnames(df_nm) <- paste0(rep(cells,2),c('intra','inter'))
	pdf(fig_name,width=width,height=height)
	df <- melt(df_nm)
	p1 <- ggplot(df,aes(x=Var2,y=value,fill=Var2)) + geom_boxplot(outlier.size=1,show.legend = F,width=0.8,outlier.shape = NA) + scale_x_discrete(labels=gsub('E14_','',rep(cells,2)))
	p1 <- p1 + scale_fill_manual(values=rep(cell_colors,2)) + xlab('') + ylab('log2(obs/exp)') + theme(legend.position = "none") + ylim(c(quantile(df_nm,0.05,na.rm=T)),quantile(df_nm,0.95,na.rm=T)*2.5)
	p1 <- p1 + stat_compare_means(comparisons = list(c(colnames(df_nm)[1],colnames(df_nm)[2]),c(colnames(df_nm)[2],colnames(df_nm)[3]),c(colnames(df_nm)[1],colnames(df_nm)[3])),label = "p.signif",method='wilcox',label.y=c(quantile(df_nm,0.95,na.rm=T)*2,quantile(df_nm,0.95,na.rm=T)*2.25,quantile(df_nm,0.95,na.rm=T)*2.5),tip.length=0.005)
	p1 <- p1 + stat_compare_means(comparisons = list(c(colnames(df_nm)[4],colnames(df_nm)[5]),c(colnames(df_nm)[5],colnames(df_nm)[6]),c(colnames(df_nm)[4],colnames(df_nm)[6])),label = "p.signif",method='wilcox',label.y=c(quantile(df_nm,0.7,na.rm=T)+0.2,quantile(df_nm,0.7,na.rm=T)+0.1,quantile(df_nm,0.7,na.rm=T)+0.32),tip.length=0.005)
	p1 <- p1 + geom_vline(xintercept = 3.5,lty=2) + annotate(geom="text", x=2, y=-.75, label="intraTAD") + annotate(geom="text", x=5, y=0.75, label="interTAD")
	print(p1)
	dev.off()
	} else {
		tad_temp <- get(load(file_f))
		if(is.null(fig_name)){
		  fig_name <- paste0(path,basename(file_f),'_',cell,'_',plot_what,'TADs.pdf')
		}
		pdf(fig_name,width=width*length(cells),height=height)
		if (!is.null(add_matrix)){
		  layout(mat = matrix(c(1:(length(cells)*2+2)), nrow = 2, ncol = length(cells)+1,byrow = F),heights = c(4, 1.5),widths = c(rep(8,length(cells)),1),respect=T) 
		} else{
		  layout(mat = matrix(c(1:(length(cells)+1)), nrow = 1, ncol = length(cells)+1,byrow = F),heights = 4,widths = c(rep(4,length(cells)),1),respect=T) 
		}
		for (cell in cells){
		#	domain <- gintervals.load(domains[grep(cell,domains)])
			if (is.null(domains)) {
				domain <- paste0("hic.",cell,".ins250_k2_domains")
				domain <- gintervals.load(domain)
			} else {
				if (!grepl('bed',domains)) {
					domain <- gintervals.load(domains)
				} else {
					domain <- read.table(domains,sep='\t',header=F)
					domain <- domain[domain[,1]%in% gintervals.all()$chrom,]
					domain <- gintervals(domain[,1],domain[,2],domain[,3])
				}
			}
			domain$len <- domain[,3]-domain[,2]
			domain <- domain[domain$len>=domain_size[1]&domain$len<=domain_size[2],]
			domain <- domain[domain$start>1e6,]
			chr_ends <- ddply(domain,.(chrom),function(x){return(max(x$end))})
			domain <- domain[!(domain$end %in% chr_ends$V1),]
			tad_list <- tad_temp[[cell]]
			tad_norm <- list()
			for (i in 1:length(tad_list$norm)){
				if(norm=='norm'){
					x <- tad_list$norm[[i]]
					} else if(norm=='obs') {
					x <- tad_list$obs[[i]]
					} else if(norm=='score') {
					  x <- tad_list$score[[i]]
					} 
				if (plot_what==''){
					if (nrow(x)==100&ncol(x)==100){
						tad_norm[[i]] <- x
					}
				} else {
					if (domain$cluster[i]==idx&(nrow(x)==100&ncol(x)==100)){
						tad_norm[[i]] <- x
					}
				}
			}
			arr <- array( unlist(tad_norm) , c(100,100,length(tad_norm)) )
			df <- apply( arr , 1:2 , mean,na.rm=T )
			if (flip){
				df <- extractDiagonal(df)
				df <- df[-1,-1]
			#	df[1,] <- 0
				df <- t(df)
				ylim=c(0,0.5)
			} else {
				df[lower.tri(df)] <- t(df)[lower.tri(df)]
				df <- rotate(df)
				ylim=c(0,1)
			}
			par(mar = c(0.1, 1, 1, 0))
			if (norm!='obs'){
				image(df,zlim=zlim,ylim=ylim, col=z_colors,xlab='',xaxt="n",yaxt="n", ylab='',xaxs='i',yaxs='i',bty='n')
			  axis(1, labels=c('',''),at=c(1/3,0.67), cex.axis=1, las=2)
			} else {
				image(log2(df),zlim=zlim,ylim=ylim, col=z_colors,xaxt="n",yaxt="n",xlab='', ylab='',xaxs='i',yaxs='i',bty='n')
			  
			}
			if (!is.null(add_matrix)){
			  cell_matrix <- add_matrix[[cell]]
			  res_df <- as.matrix(cell_matrix[,1:(ncol(cell_matrix)-2)])
			  if(is.null(mat_lim)){
			    mat_lim=c(min(res_df,na.rm=T),max(res_df,na.rm=T))
			  } 
			  par(mar = c(0.5, 1, 0.5, 0))
			  if (which(cells%in%cell)==1){
			    mat_labels <- mat_lim
			  }else{
			    mat_labels <- c("","")
			  }
			  clusterplot(res_df,separate=F,outer.col = 'none',ylim=mat_lim,quartiles.col = c('transparent','black','transparent'), fromto = c(0.25, 0.75),axes = F,size=F,xaxt="n",yaxt="n",xlab='', ylab='',xaxs='i',yaxs='i')
			  axis(2, labels=mat_labels,at=mat_lim, cex.axis=1, las=2)
			}
		}
		par(mar=c(0.1,1,1,1))
		image.scale(as.matrix(1),zlim=zlim, col=z_colors,axis.pos=4,adj=1,cex.axis = 1.2)
		dev.off()
	}
}

##############################################################################################################################################
#' Plot contact enrichment either as a function of genomic distance or total enrichment for a distance band.
#'
#' \code{plot_cis_decay}
#'
#' This function outputs and plots the contact enrichment either as a function of genomic distance or total enrichment for a distance band. It uses the output of \code{submit_cisDecayIntervals}, so it should be run after it.
#'
#' @param plot_data Full name of the file holding the data to be used for plotting.
#' @param plot_cell Vector of conditions to be plotted. Should be the same or a subset of the conditions used in \code{submit_cisDecayIntervals}.
#' @param plot_what One of 'intra','inter','total_intra','total_inter'.If 'intra' or 'inter' - plots the contact enrichment as a function of the distance either inside or outside TADs respectively.If 'total_intra' or 'total_inter' - plots the total contact enrichment either inside or outside TADs respectively.
#' @param min_dist Minimum genomic distance to use to calculate enrichment. Should be bigger than 1kb.
#' @param max_dist Maximum genomic distance to use to calculate enrichment. Should be less than the length of the biggest chromosome.
#' @param ylim If set, use this vector of two values for lower and upper limit for plotting the y-axis.
#' @param composite Boolean whether to draw the plot autonomously (TRUE) or inside a plot call (FALSE).
#' @param fig_f filename of the output figure. Will be generated inside path
#' @param fig.height Height (in inches) of the resulting figure.
#' @param fig.width Width (in inches) of the resulting figure.
#' @param colors Vector of colors to use for plotting. Should have the same length as plot_cell
#' @param disp_colors filename of the output figure. Will be generated inside path
#' @param lty line type to use. Same values as plot.
#' @param returnData Boolean whether to return calculated data. Most useful when plotting total values.
#' @param smooth Boolean whether to loess smooth the data.
#' @param legend_pos Position of the plot legend. Takes same values as default legend.
#'
#' @examples
#'
#' path <- paste0(main_f,'analysis/cis_decay/')
#' files <- list.files(paste0(main_f,'data/cis_decay/'),full.names=T)
#' plot_cis_decay(plot_data=files[grep('D0_CTCF_For',files)],plot_cell=c('D0'),plot_what='intra',composite=F,smooth=T,returnData=F,min_dist=1e5,max_dist=2e6,fig.height=6,fig.width=10,legend_pos='topleft',colors=c('blue'),disp_colors=c("lightblue"))     #Simple one interval set, one condition plot, representing the contact enrichment as a function of the genomic distance. Only pairs located inside domains and between 100kb-2MB are plotted.
#' plot_cis_decay(plot_data=files[grep('D0_CTCF_For',files)],plot_cell=c('D0','D2','D4','D6','D10'),plot_what='intra',composite=F,smooth=T,returnData=F,min_dist=1e5,max_dist=2e6,fig.height=6,fig.width=10,legend_pos='topleft')     #Simple one interval set, one condition plot, representing the contact enrichment as a function of the genomic distance. Default colors (rainbow scheme). Only pairs located inside domains and between 100kb-2MB are plotted.
#' plot_cis_decay(plot_data=files[grep('D0_CTCF_For',files)],plot_cell=c('D0','D2','D4','D6','D10'),plot_what='inter',composite=F,smooth=T,returnData=F,min_dist=1e7,max_dist=1e8,fig.height=6,fig.width=10,legend_pos='topleft')     #Simple one interval set, one condition plot, representing the contact enrichment as a function of the genomic distance. Default colors (rainbow scheme). Only pairs located outside domains and between 10-100MB are plotted.
#'
#' #Complex composite plotting combining multiple interval pairs in one plot
#'
#' dist = 10^seq(4,8,by=0.1)
#' min_dist=1e4
#' max_dist=1e6
#' ylim=c(0,1.5)
#' name <- 'sati_k9'
#' min_ind <- findInterval(min_dist,dist)
#' max_ind <- findInterval(max_dist,dist)
#' dist <- dist[min_ind:max_ind]
#' pdf(paste0(path,name,'_intra.pdf'),width=8,height=6)
#' plot(log10(dist),y=rep(NA,length(dist)),ylim=ylim,type='n',main=name,ylab="log2(obs/exp)",xaxt='n',xlab='')
#' magaxis(1,majorn=5,unlog=TRUE,grid=T)
#' 	plot_cis_decay(plot_data=files[grep('D6_H3K9me3',files)],plot_cell=c('D0'),plot_what='total_intra',min_dist=min_dist,max_dist=max_dist,composite=T,colors=c('blue'),disp_colors=c("lightblue"),smooth=T,returnData=T)
#' 	plot_cis_decay(plot_data=files[grep('D6_H3K9me3',files)],plot_cell=c('D2'),plot_what='total_intra',min_dist=min_dist,max_dist=max_dist,composite=T,colors=c('blue'),disp_colors=c("lightblue"),smooth=T,returnData=T)
#' 	plot_cis_decay(plot_data=files[grep('D6_H3K9me3',files)],plot_cell=c('D6'),plot_what='total_intra',min_dist=min_dist,max_dist=max_dist,composite=T,colors=c('blue'),disp_colors=c("lightblue"),smooth=T,returnData=T)
#' 	plot_cis_decay(plot_data=files[grep('D6_H3K9me3',files)],plot_cell=c('D10'),plot_what='total_intra',min_dist=min_dist,max_dist=max_dist,composite=T,colors=c('blue'),disp_colors=c("lightblue"),smooth=T,returnData=T)
#' 	legend(x="topleft",legend=c('D0','D2','D6','D10'),cex=1.5,lty=rep(1,2),col=c('blue','darkgreen','red'))
#' grid(nx=0,ny=NULL)
#' dev.off()
#'
#' @export
##########################################################################################################
plot_cis_decay <- function(plot_data,plot_cell=cells,plot_what=c('intra','inter','total_intra','total_inter'),min_dist=1e4,max_dist=1e8,ylim=NULL,composite=FALSE,fig_f=paste0(path,name,'.pdf'),fig.height=4,fig.width=4,colors=rainbow(length(cells)),disp_colors=rainbow(length(cells)),legend_pos='topright',lty=1,returnData=FALSE,smooth=F,norm=T){
	plot_data <- get(load(plot_data))
	data_col <- list()
	dist = 10^seq(4,8,by=0.1)
	min_ind <- findInterval(min_dist,dist)
	max_ind <- findInterval(max_dist,dist)
	dist <- dist[min_ind:max_ind]
	if (grepl('total',plot_what)){
		means <- data.frame(matrix(NA, nrow = 1, ncol = length(plot_cell)))
		colnames(means)=plot_cell
		sd_df <- means
		for (i in 1:length(plot_cell)){
			cell <- plot_cell[i]
			data <- plot_data[[cell]]
			if (plot_what=='total_intra'){
				if (norm){
					data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_intra'])))))/colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_intra'])))))
				} else {
					data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_intra'])))))					
				}
			} else if(plot_what=='total_inter'){
				if (norm){
					data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_inter'])))))/colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_inter'])))))
				} else {
					data <- colSums(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_inter'])))))				
				}
			}
			if (norm){
				data_col[[cell]] <- log2(data)
				means[,i]  <- mean(log2(data),na.rm=T)
				sd_df[,i] <- sd(log2(data),na.rm=T)/sqrt(length(data))
			} else {
				data_col[[cell]] <- data
				means[,i]  <- mean(data,na.rm=T)
				sd_df[,i] <- sd(data,na.rm=T)/sqrt(length(data))
			}
		}
		dist <- 10^seq(1,length(plot_cell),by=1)
	} else {
		means <- data.frame(matrix(NA, nrow = length(dist), ncol = length(plot_cell)))
		colnames(means)=plot_cell
		row.names(means) <- round(dist,0)
		sd_df <- means
		for (i in 1:length(plot_cell)){
			cell <- plot_cell[i]
			data <- plot_data[[cell]]
			if (plot_what=='intra'){
				if (norm){
					data <- log2(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_intra']))))/as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_intra'])))))
				} else {
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_intra']))))				
				}
			} else if(plot_what=='inter'){
				if (norm){
					data <- log2(as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_inter']))))/as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'exp_inter'])))))
				} else {
					data <- as.data.frame((lapply(data, function(x) as.numeric(x[seq(min_ind,max_ind,by=1),'obs_inter']))))			
				}
			}
			data_col[[cell]] <- data
			row.names(data) <- dist
			is.na(data) <- sapply(data, is.infinite)
			means[,i] <- apply(data,1,mean,na.rm=T)
			sd_df[,i] <- apply(data,1,sd,na.rm=T)/sqrt(ncol(data))
		}
	}
	if (!composite){
		plot_max <- max(means+sd_df,na.rm=T)
		plot_min <- min(means-sd_df,na.rm=T)
		pdf(fig_f,width=fig.width,height=fig.height)

		plot(log10(dist),y=rep(NA,length(dist)),ylim=if(is.null(ylim)){c(plot_min,plot_max)} else {ylim},type='n',ylab="log2(obs/exp)",xaxt='n',xlab='')          #,main=paste0(name,'_',plot_what)
		if(grepl('total',plot_what)){
			axis(1, at=log10(dist),labels=plot_cell, las=1,cex.axis=1.5)
		} else {
			magaxis(1,majorn=5,unlog=TRUE,grid=T)
			#minor.ticks.axis(1,5,mn=log10(min(dist)),mx=log10(max(dist)))
		}
	}
		if (grepl('total',plot_what)){
				dispersion(log10(dist),means[1,],sd_df[1,],display.NA=FALSE,type='l',fill=makeTransparent(ifelse(grepl('intra',plot_what),'orange','purple'),alpha=0.5))
				lines(log10(dist),means[1,],col=ifelse(grepl('intra',plot_what),'orange4','purple4'),lwd=2,lty=lty)
		} else {
			for (i in (1:ncol(means))){
				if (smooth){
					dispersion(log10(dist),predict(loess(means[,i] ~ log10(dist), data.frame(x=log10(dist), y=means[,i]))),predict(loess(sd_df[,i] ~ log10(dist), data.frame(x=log10(dist), y=sd_df[,i]))),display.NA=FALSE,type='l',fill=makeTransparent(as.character(disp_colors[i]),alpha=0.5))
					lines(log10(dist),predict(loess(means[,i] ~ log10(dist), data.frame(x=log10(dist), y=means[,i]))),col=colors[i],lwd=2,lty=lty)
				} else {
					dispersion(log10(dist),means[,i],sd_df[,i],display.NA=FALSE,type='l',fill=makeTransparent(as.character(disp_colors[i]),alpha=0.5))
					lines(log10(dist),means[,i],col=colors[i],lwd=2,lty=lty)
				}
			}
		}
	if (!composite){
		grid(nx=0,ny=NULL)
		legend(x=legend_pos,legend=if(grepl('total',plot_what)){gsub('total_','',plot_what)} else {colnames(means)},cex=1.5,lty=rep(1,ncol(means)),col=if(plot_what=='total_intra'){'orange4'} else if (plot_what=='total_intra'){'purple4'} else {colors},bg='white')
		dev.off()
	}
	cov_df <- plot_data$stats
	cov_df <- cov_df[complete.cases(cov_df),-c(2,3)] 
	if(length(plot_cell)==1){cov_df <- cov_df[grep(plot_cell,row.names(cov_df)),]}
	if(returnData){return(list(means=means,sd=sd_df,data=data_col,coverage=cov_df,ratio=data_col[[1]]/cov_df$coverage))}
}


##############################################################################################################################################
#' Plot contact enrichment either as a function of genomic distance or total enrichment for a distance band.
#'
#' \code{plot_contactDistribution}
#'
#' This function outputs and plots the contact enrichment as a density distribution of the scores for each pair. It uses the output of \code{submit_cisDecayIntervals}, so it should be run after it.
#'
#' @param plot_data Full name of the file holding the data to be used for plotting.
#' @param plot_cell Vector of conditions to be plotted. Should be the same or a subset of the conditions used in \code{submit_cisDecayIntervals}.
#' @param plot_what One of 'intra','inter'.If 'intra' or 'inter' - plots the distribution of the scores for pairs inside or outside TADs respectively.
#' @param min_dist Minimum genomic distance to use to calculate enrichment. Should be bigger than 1kb.
#' @param max_dist Maximum genomic distance to use to calculate enrichment. Should be less than the length of the biggest chromosome.
#' @param ylim If set, use this vector of two values for lower and upper limit for plotting the y-axis.
#' @param composite Boolean whether to draw the plot autonomously (TRUE) or inside a plot call (FALSE).
#' @param fig_f filename of the output figure. Will be generated inside path
#' @param fig.height Height (in inches) of the resulting figure.
#' @param fig.width Width (in inches) of the resulting figure.
#' @param colors Vector of colors to use for plotting. Should have the same length as plot_cell
#' @param disp_colors filename of the output figure. Will be generated inside path
#' @param lty line type to use. Same values as plot.
#' @param returnData Boolean whether to return calculated data. Most useful when plotting total values.
#' @param smooth Boolean whether to loess smooth the data.
#' @param legend_pos Position of the plot legend. Takes same values as default legend.
#' @param plot_style Should the plot be plotted as cumulative density or normal distribution. One of "ecdf" or "normal".
#'
#' @examples
#'
#' path <- paste0(main_f,'analysis/cis_decay/')
#' files <- list.files(paste0(main_f,'data/cis_decay/'),full.names=T)
#' score_files <- files[grep('_score',files)]
#' 
#' name <- 'CTCF4'
#' plot_contactDistribution(plot_data=score_files[grep('D6_CTCF_For.bed_D6_CTCF_Rev',score_files)],plot_cell='D6',plot_what='intra',composite=F,returnData=F,min_dist=1e4,max_dist=1e8,fig.height=10,fig.width=10,legend_pos='topleft')
#' plot_contactDistribution(plot_data=score_files[grep('D0_activeTss_D0_activeTss',score_files)],plot_cell='D0',plot_what='intra',composite=F,returnData=F,min_dist=1e5,max_dist=1e7,fig.height=10,fig.width=10,legend_pos='topleft')
#' 
#' 
#' ### Plot composite distributions #######
#' 
#' ylim=c(0,0.015) # for plot_style='norm'
#' ylim=c(0,1)   #for plot_style='ecdf'
#' 
#' name <- 'CTCF'	
#' fig_f <- paste0(path,name,'_scoreDist.pdf')
#' 
#' pdf(fig_f,width=8,height=8)
#' x_axis <- seq(-100,100,by=25)
#' plot(x_axis,y=rep(NA,length(x_axis)),ylim=ylim,type='n',xaxt='n',ylab="Score density",xlab='')          #,main=paste0(name,'_',plot_what)
#' axis(1,at=x_axis,labels=x_axis)
#' 
#' res1 <- plot_contactDistribution(plot_data=score_files[grep('D6_CTCF_For.bed_D6_CTCF_Rev',score_files)],plot_cell='D6',plot_what='intra',plot_style='normal',composite=T,returnData=T,min_dist=1e5,max_dist=1e7,colors='red',lty=1)
#' res2 <- plot_contactDistribution(plot_data=score_files[grep('D6_CTCF_For.bed_D6_CTCF_Rev',score_files)],plot_cell='D6',plot_what='inter',plot_style='normal',composite=T,returnData=F,min_dist=1e5,max_dist=1e7,colors='grey',lty=1)
#' 
#' legend(x='topleft',legend=c('intraTAD_CTCF','interTAD_CTCF'),cex=1.5,lty=c(1,2),col=c('red','grey'),bg='white')
#' dev.off()
#'
#' @export
##########################################################################################################
plot_contactDistribution <- function(plot_data,plot_cell=cells,plot_what=c('intra','inter'),min_dist=1e4,max_dist=1e8,ylim=NULL,composite=FALSE,fig_f=paste0(path,name,'_dist.pdf'),fig.height=4,fig.width=4,colors=rainbow(length(cells)),legend_pos='topright',lty=1,returnData=FALSE,plot_style='norm'){
	plot_data <- get(load(plot_data))
	data_col <- list()
	return_data <- list()
	for (i in 1:length(plot_cell)){
		cell <- plot_cell[i]
		if (plot_what=='intra'){
			data <- plot_data[[cell]]$intra
		} else if(plot_what=='inter'){
			data <- plot_data[[cell]]$inter
		}
		data$len <- data$start2 - data$start1
		data <- data[complete.cases(data),]
		v_score <- data[data$len>min_dist&data$len<max_dist,'v_score']
		data_col[[cell]] <- v_score 
		return_data[[cell]] <- data
	}
	plot_max <- as.numeric(sapply(data_col,function(x){return(max(density(x)$y))}))

	if (!composite){
		pdf(fig_f,width=fig.width,height=fig.height)
		x_axis <- seq(-100,100,by=25)
		plot(x_axis,y=rep(NA,length(x_axis)),ylim=if(is.null(ylim)){c(0,plot_max)} else {ylim},type='n',xaxt='n',ylab="Score density",xlab='')          #,main=paste0(name,'_',plot_what)
		axis(1,at=x_axis,labels=x_axis)
	}
	for (i in 1:length(plot_cell)){
		if(plot_style!='ecdf'){
			lines(density(data_col[[i]]),col=colors[i],lwd=2,lty=lty)
		} else {
			lines(ecdf(data_col[[i]]),col=colors[i],lwd=2,lty=lty)
		}
	}
	if (!composite){
		legend(x=legend_pos,legend=paste0(cell),cex=1.5,lty=lty,col=colors,bg='white')
		dev.off()
	}
	if(returnData){
		tss <- gintervals.load(tss_f)
		for (i in plot_cell){
			subset_data <- return_data[[plot_cell]]
			anchors <- subset_data[,c(1:3,8)]
			colnames(anchors) <- c('chrom','start','end','intervalID')
			anch_genes <- gintervals.neighbors(anchors,tss)
			targets <- subset_data[,c(4:6,8)]
			colnames(targets) <- c('chrom','start','end','intervalID')
			target_genes <- gintervals.neighbors(targets,tss)
			df <- merge(anch_genes[,c('chrom','start','end','intervalID','geneName','dist')],target_genes[,c('chrom','start','end','intervalID','geneName','dist')],by='intervalID',sort=F)
			df$score <- subset_data$v_score[match(df$intervalID,subset_data$intervalID)]
			df$len <- df$start.y-df$start.x
			write.table(df[,-1], file=gsub('.pdf',paste0(cell,'_',plot_what,'.tsv'),fig_f), quote=F,sep='\t',col.names=T,row.names=F)
		}
		return(v_score)
	}
}

##############################################################################################################################################
#' Plot aggregate Hi-C to quantify the contact enrichment between two intervals.
#'
#' \code{plot_aggregateHiC}
#'
#' This function plots binned contact enrichment in a square centered around pairs of intervals using data generated with \code{submit_aggregateHiC}.
#'
#' @param cells Conditions to work on, should be the same as the call to \code{submit_aggregateHiC}.
#' @param pool Boolean whether to pool data from individual replicates or generate separate plots per replicate.
#' @param intervals1 Either gintervals or bed files with peak coordinates of the first regions. Same as in the call to \code{submit_aggregateHiC}.
#' @param intervals2 Either gintervals or bed files with peak coordinates of the second regions. Same as in the call to \code{submit_aggregateHiC}.
#' @param range_f Distance of the square emanating from the center of the pair to be examined. Increase this and decrease resolution for sparse data. Not recommended to exceed 80kb.
#' @param filter_f If not zero, all the pairs will first be filtered based on the maximum hi-c score in them and only pairs with higher than this value will be retained. Not recommended.
#' @param res_f Size of the bin to estimate contact enrichment when extracting the data. Recommended value for sparse data - 1kb, for high-resolution data - 500bp. This can be increased but not decreased when plotting (i.e. combining bins).
#' @param plot_res Size of the bin to estimate contact enrichment when plotting the data. Should be a multiple of the res_f parameter - i.e. if res_f=1000, plot_res can be 1000,2000,4000, etc.
#' @param grid_mode One of '1D','2D','merged'. If 1D - it will create only pairs between first intervals as upstream and second intervals as downstream anchors. If 2D, it will also include pairs where interval2 is upstream. if merged - it will create pairs by matching each row in the intervals1 file with the corresponding row in the intervals2. This mode is useful for premade pairs - for example per gene, or using juicebox.
#' @param path Folder to store the generated plots.
#' @param zlim Vector of 2 values determining the lower and upper limit of the resulting plot.
#' @param interval1_name Desired name for interval1 to be plotted.
#' @param interval2_name Desired name for interval1 to be plotted.
#' @param which_plot Vector of numbers (1-6) indicating which of the desired combination of genomic ranges and domains to plot. Users can select from the 6 plots generated with default parameters.
#' @param plot_scale Boolean whether to plot scalebar or not.
#'
#' @examples
#'
#' cells <- c('D0','D6','D10')
#' for (cell in cells){
#'   plot_aggregateHiC(cells=cell,pool=T,intervals1=paste0(cell,'_H3K4me3_noCTCF.bed'),intervals2=paste0(cell,'_H3K4me3_noCTCF.bed'),range_f=40000,filter_f=0,res_f=1000,plot_res=4000,grid_mode='1D',zlim=c(-0.5,0.5),which_plot=c(1:6))
#' }
#'
#' @export
##########################################################################################################
plot_aggregateHiC <- function(cells,pool=T,intervals1,intervals2,range_f,filter_f=0,res_f,plot_res=res_f,grid_mode,path=paste0(main_f,'analysis/aggregateHiC/'),zlim=c(-1,1),interval1_name=basename(intervals1),interval2_name=basename(intervals2),which_plot=c(1:6),plot_scale=F,plot_mean=T,add_plot=F,use_score=F){
	f1=basename(intervals1)
	f2=basename(intervals2)
	bands_matrix <- as.data.frame(cbind(c(5e4,5e4,5e4,2e5,2e5,2e6),c(2e5,2e6,2e6,2e6,2e6,10e6)))
	if(grepl('exonQ',intervals1)){bands_matrix <- as.data.frame(cbind(c(2e5,2e6,10e6),c(2e6,10e6,50e6)))}
	if(grepl('Exon',intervals1)){bands_matrix <- as.data.frame(cbind(c(2e6,10e6),c(10e6,50e6)))}
	grid_min = -range_f
	grid_max = range_f
	grid_res = res_f
	h_labels <- c(interval1_name)
	v_labels <- c(interval2_name)
	for (cell in cells){
		if (pool){
			suppressMessages(pool_aggregateHiC(cells=cell,intervals1,intervals2,range_f,filter_f,res_f,grid_mode,plot_res))
			file_idx <- paste0(f1,'.',f2,'.',range_f,'.',res_f,'.',grid_mode,'.',filter_f,'.',cell)
			grid_fns <- list.files(paste0(main_f,'data/aggregateHiC/'),pattern=file_idx,full.names=T)
		} else {
			file_idx <- paste0(f1,'.',f2,'.',range_f,'.',res_f,'.',grid_mode,'.',filter_f)
			files <- list.files(paste0(main_f,'data/aggregateHiC/'),pattern=paste0('.',file_idx),full.names=T)
			files <- files[grep(cell,files)]
			grid_fns <- files[grep(paste0(cell,'\\.'),files,invert=T)]
		}


		for (grid_fn in grid_fns){
		  image_file = paste0(path,basename(grid_fn),'_',plot_res/1000,'kb.pdf')
			load(file=grid_fn)
			message('Working on file:',grid_fn)
			#### Initialize Plot ####
			if (!add_plot){
			  pdf(image_file, width=ifelse(plot_scale,4,3), height=length(which_plot)*3)
			  imgGrid <- matrix(c(1:2),nrow=1,byrow=T)
			  if(plot_scale){
			    layout(imgGrid, widths = c(10,2), heights = 10, respect = T)
			  } else {
			    par(mfrow=c(length(which_plot),1))
			  }
			}
			for (i in which_plot) {
			   if (i == 1 | i == 2 | i == 4){
			   domains = 'intra'
			   } else if (i==6){
			   domains = 'long-range'
			   } else {
			   domains='inter'
			   }
			   dist_labels <- c(paste0(bands_matrix[i,1]/1000,'kb'),paste0(bands_matrix[i,2]/1e6,'mb'))
			   if (grid_res!=plot_res) {
			   o = suppressMessages(split_and_merge_matrix(grid$obs[[i]], grid_min, grid_max, grid_res, plot_res))
			   } else { o= grid$obs[[i]] }
			   if (grid_res!=plot_res) {
			   e = suppressMessages(split_and_merge_matrix(grid$exp[[i]], grid_min, grid_max, grid_res, plot_res))
			   } else { e= grid$exp[[i]] }
			   if(!use_score){
			   center_v <- sum(o[(which(colnames(o)==0)-1):(which(colnames(o)==0)+1),(which(colnames(o)==0)-1):(which(colnames(o)==0)+1)]*grid$total_obs,na.rm=T)/(sum(e[(which(colnames(e)==0)-1):(which(colnames(e)==0)+1),(which(colnames(e)==0)-1):(which(colnames(e)==0)+1)]*grid$total_exp,na.rm=T)/2)
			   left_top <- sum(o[2:4,2:4]*grid$total_obs,na.rm=T)/(sum(e[2:4,2:4]*grid$total_exp,na.rm=T)/2)
			   left_bottom <- sum(o[(nrow(o)-3):(nrow(o)-1),2:4]*grid$total_obs,na.rm=T)/(sum(e[(nrow(o)-3):(nrow(o)-1),2:4]*grid$total_exp,na.rm=T)/2)
			   right_top <- sum(o[2:4,(ncol(o)-3):(ncol(o)-1)]*grid$total_obs,na.rm=T)/(sum(e[2:4,(ncol(o)-3):(ncol(o)-1)]*grid$total_exp,na.rm=T)/2)
			   right_bottom <- sum(o[(nrow(o)-3):(nrow(o)-1),(ncol(o)-3):(ncol(o)-1)]*grid$total_obs,na.rm=T)/(sum(e[(nrow(o)-3):(nrow(o)-1),(ncol(o)-3):(ncol(o)-1)]*grid$total_exp,na.rm=T)/2)
			   if(plot_mean){
			     main_text <- round(center_v/mean(left_top,left_bottom,right_top,right_bottom),2)
			   } else {
			     main_text <- ''
			   }			   
			   par(mar=c(1.5,0.5,1.5,0.5),mgp=c(1,0.5,0))   
			   blue_white_pal = colorRampPalette(c("purple", "navy", "blue", "#87FFFF","#F5FEFF"))
			   white_red_pal = colorRampPalette(c("#FFF7F7","#FF413D", "black", "orange", "yellow"))
			   averageLoop_colors <- c(blue_white_pal(length(seq(zlim[1],-0.005,by=0.005))),'white',white_red_pal(length(seq(0.005,zlim[2],by=0.005))))
			   mat <- as.matrix(log2(o/e))
			   mat[mat>zlim[2]] <- zlim[2]
			   mat[mat<zlim[1]] <- zlim[1]
			   # averageLoop_colors <- colorRampPalette(c("#000080","#0000FF","#78DBFF","#BFF5F4","#F5F5F5","#FFD9DF","#FA362F","#7A2F18","#FCDB05"))(201)
			   image(mat, zlim=zlim,  col=averageLoop_colors, xaxt="n",yaxt="n",xlab='', ylab='',main='',cex.main=ifelse(length(which_plot)==3,1.3,1),font=3)

		       		#	   text(round(center_v/left_bottom,2),x=0.1,y=0.1,cex = 1,font=2)
			   text(main_text,x=0.9,y=0.95,cex = 1.2,font=2)
			   axis(1,tck = -.01,cex.axis=ifelse(length(which_plot)==3,2,1.2), labels=h_labels,at=0.5,padj=-0.5)  #,padj=-0.5
			   axis(4,tck = -.01,cex.axis=ifelse(length(which_plot)==3,2,1.2), labels=v_labels,at=0.5,padj=-0.5)			#,padj=-0.5
			   abline(v=0.5, col="grey20",lty=2)
			   abline(h=0.5, col="grey20",lty=2)
			   if(plot_scale){
			   par(mar=c(2,1.2,2,1))
			   image.scale.aggregate(as.matrix(log2(o/e)),zlim=zlim, col=averageLoop_colors,axis.pos=4,label='')
			   }
			   return(list(input=as.matrix(log2(o/e)),zlim=zlim,cols=averageLoop_colors))
			   message(paste("grid size=", grid$grid_size[i], ", max obs=", max(log10(o)), ", max obs/exp=", max(log2(o/e)),", enrichment= ",paste0(grid$enrich[[i]],collapse=',')))
			   } else{
			     o <- o[-1,-ncol(o)]
			     center_v <- mean(o[(ceiling(ncol(o)/2)-1):(ceiling(ncol(o)/2)+1),(ceiling(ncol(o)/2)-1):(ceiling(ncol(o)/2)+1)],na.rm=T)+100
			     left_top <- mean(o[2:4,2:4],na.rm=T)+100
			     left_bottom <- mean(o[(nrow(o)-3):(nrow(o)-1),2:4],na.rm=T)+100
			     right_top <- mean(o[2:4,(ncol(o)-3):(ncol(o)-1)],na.rm=T)+100
			     right_bottom <- mean(o[(nrow(o)-3):(nrow(o)-1),(ncol(o)-3):(ncol(o)-1)],na.rm=T)+100
			     if(plot_mean){
			       main_text <- round(center_v/mean(left_top,left_bottom,right_top,right_bottom),2)
			     } else {
			       main_text <- ''
			     }			   
			     par(mar=c(0.5,0.5,0.5,0.5),mgp=c(1,0.5,0))   
			     blue_white_pal = colorRampPalette(c("purple", "navy", "blue", "#87FFFF","#F5FEFF"))
			     white_red_pal = colorRampPalette(c("#FFF7F7","#FF413D", "black", "orange", "yellow"))
			     averageLoop_colors <- c(blue_white_pal(length(seq(zlim[1],-0.005,by=0.005))),'white',white_red_pal(length(seq(0.005,zlim[2],by=0.005))))
			     mat <- o
			     mat[mat>zlim[2]] <- zlim[2]
			     mat[mat<zlim[1]] <- zlim[1]
			     # averageLoop_colors <- colorRampPalette(c("#000080","#0000FF","#78DBFF","#BFF5F4","#F5F5F5","#FFD9DF","#FA362F","#7A2F18","#FCDB05"))(201)
			     image(mat, zlim=zlim,  col=averageLoop_colors, xaxt="n",yaxt="n",xlab='', ylab='',main='',cex.main=ifelse(length(which_plot)==3,1.3,1),font=3)
			     
			     #	   text(round(center_v/left_bottom,2),x=0.1,y=0.1,cex = 1,font=2)
			     text(main_text,x=0.9,y=0.95,cex = 1.2,font=2)
			     axis(1,tck = -.01,cex.axis=ifelse(length(which_plot)==3,2,1.2), labels=h_labels,at=0.5,padj=-0.5)  #,padj=-0.5
			     axis(4,tck = -.01,cex.axis=ifelse(length(which_plot)==3,2,1.2), labels=v_labels,at=0.5,padj=-0.5)			#,padj=-0.5
			     abline(v=ncol(o)/2, col="grey20",lty=2)
			     abline(h=nrow(o)/2, col="grey20",lty=2)
			     if(plot_scale){
			       par(mar=c(2,1.2,2,1))
			       image.scale.aggregate(o,zlim=zlim, col=averageLoop_colors,axis.pos=4,label='')
			     }
			     return(list(input=o,zlim=zlim,cols=averageLoop_colors))
			     message(paste("grid size=", grid$grid_size[i], ", max obs=", max(o),", enrichment= ",paste0(grid$enrich[[i]],collapse=',')))
			     
			   }
			}
			if(!add_plot){
			  dev.off()
			}
		}
	}
}

##############################################################################################################################################
#' Plot aggregate Hi-C to quantify the chromatin insulation at genomic regions.
#'
#' \code{plot_aggregateDiagonal}
#'
#' This function plots binned contact enrichment in a rectangle centered around genomicintervals using data generated with \code{submit_aggregateDiagonal}.
#'
#' @param cells Conditions to work on, should be the same as the call to \code{submit_aggregateHiC}.
#' @param pool Boolean whether to pool data from individual replicates or generate separate plots per replicate.
#' @param intervals1 Either gintervals or bed files with peak coordinates of the genomics regions. Same as in the call to \code{submit_aggregateHiC}.
#' @param maxDist  Maximum distance to be considered when calculating enrichment.
#' @param filter_f If not zero, all the pairs will first be filtered based on the maximum hi-c score in them and only pairs with higher than this value will be retained. Not recommended.
#' @param res Size of the bin to estimate contact enrichment when extracting the data. Recommended value for sparse data - 1kb, for high-resolution data - 500bp. This can be increased but not decreased when plotting (i.e. combining bins).
#' @param plot_res Size of the bin to estimate contact enrichment when plotting the data. Should be a multiple of the res_f parameter - i.e. if res_f=1000, plot_res can be 1000,2000,4000, etc.
#' @param consider_strand Boolean indicating whether to reorient intervals based on strand of the nearest tss.
#' @param path Folder to store the generated plots.
#' @param zlim Vector of 2 values determining the lower and upper limit of the resulting plot.
#' @param interval1_name Desired name for interval1 to be plotted.
#' @param plot_scale Boolean whether to plot scalebar or not.
#'
#' @examples
#'
#' plot_aggregateDiagonal(cells=c('D0','D2'),pool=T,intervals_f='/work/project/Cavalli-mammals/satish/HiC/data/peaks/processed/D0_CTCF.bed',res=500,consider_strand='FALSE',zlim=c(-1,1))
#'
#' @export
##########################################################################################################
plot_aggregateDiagonal <- function(cells,pool=T,intervals1,maxDist=2e5,filter_f=0,res,plot_res=res,consider_strand='FALSE',path=paste0(main_f,'analysis/aggregateDiagonal/'),zlim=c(-1,1),interval_name=basename(intervals1),plot_scale=T){
	f1=basename(intervals1)
	for (cell in cells){
		if (pool){
			pool_aggregateDiagonal(cells,intervals1,maxDist,res,filter_f,consider_strand)
			file_idx <- paste0(f1,'.',maxDist,'.',res,'.',consider_strand,'.',filter_f,'.',cell)
			grid_fns <- list.files(paste0(main_f,'data/aggregateDiagonal/'),pattern=file_idx,full.names=T)
		} else {
			file_idx <- paste0(f1,'.',maxDist,'.',res,'.',consider_strand,'.',filter_f)
			files <- list.files(paste0(main_f,'data/aggregateDiagonal/'),pattern=paste0('.',file_idx),full.names=T)
			grid_fns <- files[grep(cell,files)]
		}
		grid_min = -maxDist
		grid_max = maxDist
		grid_res = res

		h_labels <- c(paste0(grid_min/1000,'kb'),paste0(grid_min/2000,'kb'),interval_name,paste0('+',grid_max/2000,'kb'),paste0('+',grid_max/1000,'kb'))
		v_labels <- c('',paste0(grid_max*0.50/1000,'kb'),paste0(grid_max/1000,'kb'))

		for (grid_fn in grid_fns){
			message('Working on: ',grid_fn)
			image_file = paste0(path,basename(grid_fn),'_',plot_res/1000,'.pdf')
			load(file=grid_fn)
			message(length(grid$obs))
			#### Initialize Plot ####
			pdf(image_file, width=12, height=length(grid$obs)*4)
			imgGrid <- matrix(c(1:3),nrow=1)
			if (length(grid$obs)!=1) { for(i in (1:(length(grid$obs)-1))){imgGrid <- rbind(imgGrid,matrix(c((max(imgGrid)+1):(max(imgGrid)+ncol(imgGrid))),nrow=1))}}
			layout(imgGrid, widths = rep(c(10,1,1)), heights = rep(5,5,5), respect = T)
			par(mar=c(5.1, 1.1, 4.1, 3.1))
			for (i in 1:length(grid$obs)) {

				if (grid_res!=plot_res) {
					o = split_and_merge_matrix(grid$obs[[i]], grid_min, grid_max, grid_res, plot_res)
				} else { o= grid$obs[[i]] }
				if (grid_res!=plot_res) {
					e = split_and_merge_matrix(grid$exp[[i]], grid_min, grid_max, grid_res, plot_res)
				} else { e= grid$exp[[i]] }

				main_txt <- paste0("N: ", grid$grid_size[i])
				#main_txt <- ""

				avgTable <- log2(as.matrix(o/e))
				diagMatrix <- extractDiagonal(avgTable)
				diagMatrix <- diagMatrix[-1,]
				diagMatrix[1,] <- 0
				image(t(diagMatrix), col=wide_red_blue_pal(1000),zlim=zlim, ylim=c(0,0.5),xlab='', ylab='', yaxt='n', xaxt='n', frame=F,main=main_txt,cex.main=1.8,font.main=3)  #
				axis(1,cex.axis=3, labels=h_labels,at=seq(0,1,length=length(h_labels)),padj=0.5)
				axis(2,cex.axis=3, labels=v_labels,at=seq(0,0.5,length=length(v_labels)),padj=-0.1)
				grid(nx=0,ny=4,lwd=1,col='grey70',lty=5)
				segments(0.5,0,1,1, col="grey40",lty=5,lwd=1.2)    ##### Do not touch anymore
				segments(0.5,0,0,1, col="grey40",lty=5,lwd=1.2)	  ##### Do not touch anymore
				par(mar=c(5,2,4,2))
				if(plot_scale){image.scale(as.matrix(diagMatrix),zlim=zlim, col=wide_red_blue_pal(1000),axis.pos=4,adj=1)}
				message(paste("grid size=", grid$grid_size[i], ", max obs=", max(log10(o)), ", max obs/exp=", max(log2(o/e))))
			}
			dev.off()
		}
	}
}

